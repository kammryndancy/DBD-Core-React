0010 ! <DBSQLGEN> Generate SQL and other types of strings from providex.ddf/dde files
0035 REM "5.7 - 11/07/17 - 10.620555 - crg - SSP# 296394
0037 REM "296394-Needs help exporting single tables from DBD                 
0040 REM "Copyright 2017 Demand Bridge, LLC.; Norcross, Georgia
0041 REM "        Licensed Software - All Rights Reserved.
0050 ! Where:
0060 ! contents$   - The sql CREATE commands will be returned in this field
0070 ! errmsg$     - Warnings and Error messages are returned
0080 ! tablename$  - Logical table name
0090 ! ddf_path$   - pathname of the providex.ddf file (optional - default to simple path)
0091 ! quo_char$   - character used for enclosing,tables, columns and indexes names (optional - default is null)
0092 ! str_type$   - Return string type: SQL - SQL for TABLE and INDEX CREATE, IOL - IOLIST for writing text data file, CTL - Oracle SQLLDR or MySQL Bulk Lod control file contents, KEY - String of comma-separated key segments
0093 ! db_type$    - Database type - O:Oracle, M:MySQL, S:SQL Server
0094 ! tcase_type$  - Tablename case type - U:Upper, L:Lower (other option values ignored)
0100 ! ^100
0110 ENTER CONTENTS$,ERRMSG$,TABLENAME$,DDF_PATH$,QUO_CHAR$,STR_TYPE$,DB_TYPE$,TCASE_TYPE$,ERR=*NEXT
0120 CONTENTS$="",ERRMSG$=""
0121 IF NUL(STR_TYPE$) THEN STR_TYPE$="SQL"
0122 IF NUL(DB_TYPE$) THEN DB_TYPE$="O" END_IF ; GOSUB SETUP_DATATYPES ! Defaults to Oracle
0130 IF TABLENAME$="" THEN ERRMSG$="Error:"+SEP+"Table name not specified."; GOTO ERR_EXIT
0140 IF DDF_PATH$="" THEN DDF_PATH$="providex.ddf",DDF_DIR$="" ELSE P=POS(DLM=DDF_PATH$),DDF_DIR$=TBL(P=0,DDF_PATH$(1,POS(DLM=DDF_PATH$,-1)-1),"")
0150 FLAGS$="S",LOGFILE$="TableDefinition",PVXFILE$=DDF_PATH$
0160 IF LCS(PVXFILE$)<>"*providex.ddf" THEN CALL "*pvxfiles;Check",ERR=ERR_EXIT,LOGFILE$,PVXFILE$,EMSG$,FLAGS$
0170 FLAGS$="S",LOGFILE$="ElementDefinition",PVXFILE$=DDF_DIR$+DLM+"providex.dde"
0175 PVXFILE$="*providex.dde"
0180 IF LCS(PVXFILE$)<>"*providex.dde" THEN CALL "*pvxfiles;Check",ERR=ERR_EXIT,LOGFILE$,PVXFILE$,EMSG$,FLAGS$
0200 ! ^200 - Initialize database object
0210 DB=NEW("*dict/database",ERR=ERR_EXIT)
0220 RETCODE=DB'SETDATABASE(DDF_DIR$); IF RETCODE=0 THEN ERRMSG$="Error:"+SEP+"Unable to set data base: "+DDF_DIR$+SEP+MSG(ERR); GOTO ERR_EXIT
0400 ! ^200 - Create Table
0410 TABLE$=SUB(TABLENAME$," ","_")
0430 DUP_CHECK$=SEP,X$="(  "
0440 SWITCH STR_TYPE$
0441 CASE "SQL"
0442 X$="( "; CONTENTS$="CREATE TABLE "+QUO_CHAR$+TBL(POS(TCASE_TYPE$="UL"),TABLE$,UCS(TABLE$),LCS(TABLE$))+QUO_CHAR$+SEP; BREAK
0443 CASE "CTL"
0444 X$="(  "; IF DB_TYPE$="O" THEN CONTENTS$="OPTIONS (DIRECT = TRUE, ERRORS = 9999999, SILENT = (ALL))"+SEP+"LOAD DATA"+SEP+"CHARACTERSET WE8ISO8859P1"+SEP+"INFILE '"+TABLE$+".txt'"+SEP+"BADFILE '"+TABLE$+".bad'"+SEP+"DISCARDFILE '"+TABLE$+".dsc'"+SEP+"INTO TABLE "+QUO_CHAR$+TABLE$+QUO_CHAR$+SEP+"APPEND"+SEP+"FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"+QUO+"'"+SEP+"TRAILING NULLCOLS"+SEP ELSE IF DB_TYPE$="M" THEN CONTENTS$="LOAD DATA INFILE '"+TABLE$+".txt'"+SEP+"REPLACE"+SEP+"INTO TABLE "+TABLE$+SEP+"FIELDS TERMINATED BY ',' ENCLOSED BY '"+QUO+"'"+SEP+"LINES TERMINATED BY '\n'"+SEP ELSE X$=""; CONTENTS$="9.0"+SEP+"%COLCNT%"+SEP
0445 BREAK
0446 CASE "IOL"
0447 X$=""; CONTENTS$="IOLIST "
0448 BREAK
0450 END SWITCH 
0460 IF STR_TYPE$<>"SQL" THEN GOTO 0611
0531 COL_CNT=DB'GETKEYCOLUMNCOUNT(TABLENAME$)
0532 DB'SETRECORDNO(1)
0533 FOR C=1 TO COL_CNT
0550 COL=DB'GETKEYCOLUMNINFO(TABLENAME$,C)
0560 IF COL=0 THEN GOTO NOKEYCOLUMN ! Check if we have Column Object
0561 ARRAY_POS1=POS(":"=COL'OCCURS$,1,1)
0565 DTCHK$=COL'CLASS$,COLUMN_TYPE$=STR_DATATYPE$; IF DTCHK$="DATE-KKMMDD" THEN COLUMN_TYPE$=DATE_DATATYPE$
0567 SWITCH STR_TYPE$
0569 CASE "SQL"
0571 GOSUB CVT_COLUMN; IF ARRAY_POS1>0 THEN GOSUB BUILD_ARRAY_LIST ELSE IF POS(SEP+COLUMN_NAME$+SEP=DUP_CHECK$)=0 THEN DUP_CHECK$+=COLUMN_NAME$+SEP; CONTENTS$+=X$+QUO_CHAR$+COLUMN_NAME$+QUO_CHAR$+" "+TBL(COL'TYPE$="S",TBL(COL'INTERNALFORMAT$<>"B",NUM_DATATYPE$+"("+STR(COL'LENGTH),NUM_DATATYPE$+"("+STR(COL'LENGTH)+TBL(COL'SCALE=0,","+STR(COL'SCALE),""))+")",TBL(POS("DATE"=COL'CLASS$)>0,COLUMN_TYPE$+"("+STR(COL'LENGTH)+")",COLUMN_TYPE$))+","+SEP+""
0580 BREAK
0587 END SWITCH 
0590 X$=""
0600 NOKEYCOLUMN:! No Column do nothing
0610 NEXT C
0611 KEY_COL_LIST$=DB'GETKEYCOLUMNLIST$(TABLENAME$) ! Get list of key columns
0620 TYP_CNT=DB'GETRECORDTYPES(TABLENAME$)
0630 FOR TYPE=1 TO TYP_CNT
0640 DB'SETRECORDNO(TYPE)
0650 COL_CNT=DB'GETCOLUMNCOUNT(TABLENAME$)
0660 FOR C=1 TO COL_CNT
0670 COL=DB'GETCOLUMNINFO(TABLENAME$,C)
0680 IF COL=0 THEN GOTO NOCOLUMN ! Check if we have Column Object
0685 DTCHK$=COL'CLASS$,COLUMN_TYPE$=STR_DATATYPE$; IF DTCHK$="DATE-KKMMDD" THEN COLUMN_TYPE$=DATE_DATATYPE$
0686 IF POS(UCS(COL'NAME$)+SEP=KEY_COL_LIST$)<>0 THEN IS_KEY_COL=1 ELSE IS_KEY_COL=0
0690 ARRAY_POS1=POS(":"=COL'OCCURS$,1,1)
0691 SWITCH STR_TYPE$
0692 CASE "SQL"
0693 GOSUB CVT_COLUMN; IF ARRAY_POS1>0 THEN GOSUB BUILD_ARRAY_LIST ELSE IF POS(SEP+COLUMN_NAME$+SEP=DUP_CHECK$)=0 THEN DUP_CHECK$+=COLUMN_NAME$+SEP; CONTENTS$+=X$+QUO_CHAR$+COLUMN_NAME$+QUO_CHAR$+" "+TBL(COL'TYPE$="S",TBL(COL'INTERNALFORMAT$<>"B",NUM_DATATYPE$+"("+STR(COL'LENGTH),NUM_DATATYPE$+"("+STR(COL'LENGTH)+TBL(COL'SCALE=0,","+STR(COL'SCALE),""))+")",TBL(POS("DATE"=COL'CLASS$)>0,COLUMN_TYPE$+"("+STR(COL'LENGTH)+")",COLUMN_TYPE$))+","+SEP+""
0694 BREAK
0695 CASE "CTL"
0696 GOSUB CVT_COLUMN; IF ARRAY_POS1>0 THEN GOSUB BUILD_ARRAY_LIST ELSE IF POS(SEP+COLUMN_NAME$+SEP=DUP_CHECK$)=0 THEN DUP_CHECK$+=COLUMN_NAME$+SEP; IF DB_TYPE$<>"S" THEN CONTENTS$+=X$+QUO_CHAR$+COLUMN_NAME$+QUO_CHAR$; IF DB_TYPE$<>"M" THEN CONTENTS$+=TBL(POS("DATE"=COL'CLASS$)>0,TBL(COL'TYPE$="S" AND COL'LENGTH>254,""," CHAR("+STR(COL'LENGTH)+")")," DATE "+QUO+"YYYY-MM-DD"+QUO+TBL(IS_KEY_COL=1,"  NULLIF "+COLUMN_NAME$+"=BLANKS","")) END_IF ; CONTENTS$+=TBL(C>=COL_CNT,","+SEP+"   ",SEP+")") ELSE CONTENTS$+=X$+STR(C)+DIM(6)+"SQLCHAR"+DIM(6)+STR(0)+DIM(6)+STR(0)+DIM(6)+QUO+TBL(C>=COL_CNT,"\t","\r\n")+QUO+DIM(6)+STR(C)+DIM(6)+COLUMN_NAME$+DIM(6)+TBL(COL'TYPE$="S",QUO+QUO,TBL(POS("DATE"=COL'CLASS$)>0,"SQL_Latin1_General_CP1_CI_AS",QUO+QUO))+SEP
0697 BREAK
0698 CASE "IOL"
0699 GOSUB CVT_COLUMN; IF ARRAY_POS1>0 THEN GOSUB BUILD_ARRAY_LIST ELSE IF POS(SEP+COLUMN_NAME$+SEP=DUP_CHECK$)=0 THEN DUP_CHECK$+=COLUMN_NAME$+SEP; IF DB_TYPE$<>"S" THEN CONTENTS$+=X$+QUO_CHAR$+TBL(COL'TYPE$<>"S",TBL(POS("DATE"=COL'CLASS$)>0,"$22$"+","+"FN_TRANSLATE$(MID("+COLUMN_NAME$+"$,1,"+STR(COL'LENGTH)+"))"+","+"$22$","FN_TFDATE$("+COLUMN_NAME$+"$,"+QUO+"YYYY-MM-DD"+QUO+","+STR(IS_KEY_COL)+")"),"STR("+COLUMN_NAME$+")")+QUO_CHAR$+TBL(C>=COL_CNT,","+QUO+","+QUO+",","") ELSE CONTENTS$+=X$+QUO_CHAR$+TBL(COL'TYPE$<>"S",TBL(POS("DATE"=COL'CLASS$)>0,"FN_TRANSLATE$(MID("+COLUMN_NAME$+"$,1,"+STR(COL'LENGTH)+"))","FN_TFDATE$("+COLUMN_NAME$+"$,"+QUO+"YYYY-MM-DD"+QUO+","+STR(IS_KEY_COL)+")"),"STR("+COLUMN_NAME$+")")+QUO_CHAR$+TBL(C>=COL_CNT,",$09$,","")
0700 BREAK
0701 END SWITCH 
0710 X$=""
0720 NOCOLUMN:! No Column do nothing
0730 NEXT C
0740 NEXT TYPE
0750 IF STR_TYPE$<>"SQL" AND STR_TYPE$<>"KEY" THEN GOTO WRAPUP
0800 ! ^200 - Create Indices
0810 DB'SETRECORDNO(1) ! reset record type
0820 IDX_CNT=DB'GETINDEXCOUNT(TABLENAME$)
0821 IF IDX_CNT=0 THEN CONTENTS$+=")"
0830 FOR I=1 TO IDX_CNT
0840 IDX_NAME$=DB'GETINDEXNAME$(TABLENAME$,I)
0850 IDX=DB'GETINDEXINFO(TABLENAME$,I)
0860 IF IDX=0 THEN GOTO NOINDEX ! Check if we have a Index Object
0870 INDEXNAME$=IDX'NAME$; IF MID(INDEXNAME$,1,1)="#" OR MID(INDEXNAME$,1,1)="" THEN INDEXNAME$="KEY"+STR(I-1)+"_"+UCS(TABLENAME$)
0880 SEGNAMES$="",DUP_SEGNAMES$=SEP
0890 FOR S=1 TO IDX'SEGCOUNT
0900 GOSUB CVT_IDX; IF POS(SEP+IDX_NAME$+SEP=DUP_SEGNAMES$)=0 THEN SEGNAMES$+=QUO_CHAR$+IDX_NAME$+QUO_CHAR$+", "; DUP_SEGNAMES$+=IDX_NAME$+SEP
0910 IF IDX'ISUNIQUE THEN UNIQUE$="UNIQUE " ELSE UNIQUE$=""
0920 IF IDX'COLUMNWIDTH<>0 THEN ERRMSG$+="Warning:"+SEP+"Key segments based on partial fields are not supported."+SEP+"Key: "+INDEXNAME$+SEP+"Segment: "+IDX'COLUMNNAME$+"$"+"("+STR(IDX'COLUMNOFFSET+1)+","+STR(IDX'COLUMNWIDTH)+")"+SEP+SEP
0930 NEXT S
0935 IF STR_TYPE$="KEY" THEN CONTENTS$+=SEGNAMES$+SEP; GOTO *CONTINUE
0940 SEGNAMES$="("+SEGNAMES$(1,LEN(SEGNAMES$)-2)+")"
0950 IF I>1 THEN CONTENTS$+="CREATE "+UNIQUE$+"INDEX "+QUO_CHAR$+INDEXNAME$+QUO_CHAR$+" ON "+QUO_CHAR$+TBL(POS(TCASE_TYPE$="UL"),TABLE$,UCS(TABLE$),LCS(TABLE$))+QUO_CHAR$+" "+SEGNAMES$+";"+SEP ELSE CONTENTS$+="CONSTRAINT "+QUO_CHAR$+INDEXNAME$+QUO_CHAR$+" PRIMARY KEY "+SEGNAMES$+SEP+");"+SEP ! +SEP
0960 NOINDEX:! No Index Object do nothing
0970 NEXT I
1000 ! ^100 - Wrap up
1001 WRAPUP:
1010 DROP OBJECT DB
1020 XP1=POS("date("=CONTENTS$)
1050 WHILE XP1>0
1060 XP2=POS("("=CONTENTS$(XP1))
1070 CONTENTS$(XP1+4,XP2-4)=DIM(XP2-4)
1075 XP1=POS("date("=CONTENTS$)
1080 WEND 
1081 CONTENTS$=SUB(CONTENTS$,"%COLCNT%",STR(COL_CNT))
1090 EXIT 
1100 ! ^100
1110 ERR_EXIT:
1120 IF ERRMSG$="" THEN ERRMSG$="Error:"+SEP+"Generating SQL"+SEP+MSG(ERR)
1130 IF DB THEN DROP OBJECT DB
1140 EXIT ERR
1150 ! Build Array of Occurs
1160 BUILD_ARRAY_LIST:
1170 ARRAY_POS2=POS(":"=COL'OCCURS$,1,2)
1171 ARRAY_POS3=POS(":"=COL'OCCURS$,1,3)
1180 IF ARRAY_POS2>0 AND ARRAY_POS3=0 THEN GOTO BUILD_ARRAY_LIST_2_DEM
1181 IF ARRAY_POS3>0 THEN GOTO BUILD_ARRAY_LIST_3_DEM
1190 ARRAY_PART1_START$=MID(COL'OCCURS$,1,ARRAY_POS1-1)
1200 ARRAY_PART1_END$=MID(COL'OCCURS$,ARRAY_POS1-LEN(COL'OCCURS$))
1210 MASK_PART1$=DIM(LEN(ARRAY_PART1_END$),"0")
1220 COUNT1=NUM(ARRAY_PART1_START$)
1230 COUNT2=NUM(ARRAY_PART1_END$)
1240 FOR I=COUNT1 TO COUNT2 STEP 1
1245 DTCHK$=COL'CLASS$,COLUMN_TYPE$=STR_DATATYPE$; IF DTCHK$="DATE-KKMMDD" THEN COLUMN_TYPE$=DATE_DATATYPE$
1250 DUP_CHECK$+=COLUMN_NAME$+"_"+STR(I:MASK_PART1$)+SEP; CONTENTS$+=X$+QUO_CHAR$+COLUMN_NAME$+"_"+STR(I:MASK_PART1$)+QUO_CHAR$+"     "+TBL(COL'TYPE$="S",TBL(COL'INTERNALFORMAT$<>"B",NUM_DATATYPE$+"("+STR(COL'LENGTH),NUM_DATATYPE$+"("+STR(COL'LENGTH)+TBL(COL'SCALE=0,","+STR(COL'SCALE),""))+")",TBL(POS("DATE"=COL'CLASS$)>0,COLUMN_TYPE$+"("+STR(COL'LENGTH)+")",COLUMN_TYPE$))+","+SEP+"   "
1260 X$=""
1270 NEXT I
1280 RETURN 
1290 ! Build Array 2 Dimension
1300 BUILD_ARRAY_LIST_2_DEM:
1310 ARRAY_INFO1$=MID(COL'OCCURS$,1,(POS(","=COL'OCCURS$)-1))
1320 ARRAY_INFO2$=MID(COL'OCCURS$,POS(","=COL'OCCURS$)+1)
1330 ARRAY_POS1=POS(":"=ARRAY_INFO1$)
1340 ARRAY_POS2=POS(":"=ARRAY_INFO2$)
1350 ARRAY_PART1_START$=MID(ARRAY_INFO1$,1,ARRAY_POS1-1)
1360 ARRAY_PART1_END$=MID(ARRAY_INFO1$,ARRAY_POS1-LEN(ARRAY_INFO1$))
1370 MASK_PART1$=DIM(LEN(ARRAY_PART1_END$),"0")
1380 COUNT1=NUM(ARRAY_PART1_START$)
1390 COUNT2=NUM(ARRAY_PART1_END$)
1400 ARRAY_POS2=POS(":"=ARRAY_INFO2$,1,1)
1410 ARRAY_PART2_START$=MID(ARRAY_INFO2$,1,ARRAY_POS2-1)
1420 ARRAY_PART2_END$=MID(ARRAY_INFO2$,ARRAY_POS2-LEN(ARRAY_INFO2$))
1430 MASK_PART2$=DIM(LEN(ARRAY_PART2_END$),"0")
1440 COUNT3=NUM(ARRAY_PART2_START$)
1450 COUNT4=NUM(ARRAY_PART2_END$)
1460 FOR I=COUNT1 TO COUNT2 STEP 1
1470 FOR T=COUNT3 TO COUNT4 STEP 1
1475 DTCHK$=COL'CLASS$,COLUMN_TYPE$=STR_DATATYPE$; IF DTCHK$="DATE-KKMMDD" THEN COLUMN_TYPE$=DATE_DATATYPE$
1480 GOSUB CVT_COLUMN; DUP_CHECK$+=COLUMN_NAME$+"_"+STR(I:MASK_PART1$)+"_"+STR(T:MASK_PART2$)+SEP; CONTENTS$+=X$+QUO_CHAR$+COLUMN_NAME$+"_"+STR(I:MASK_PART1$)+"_"+STR(T:MASK_PART2$)+QUO_CHAR$+"     "+TBL(COL'TYPE$="S",TBL(COL'INTERNALFORMAT$<>"B",NUM_DATATYPE$+"("+STR(COL'LENGTH),NUM_DATATYPE$+"("+STR(COL'LENGTH)+TBL(COL'SCALE=0,","+STR(COL'SCALE),""))+")",TBL(POS("DATE"=COL'CLASS$)>0,COLUMN_TYPE$+"("+STR(COL'LENGTH)+")",COLUMN_TYPE$))+","+SEP+"   "
1490 X$=""
1500 NEXT T
1510 NEXT I
1520 RETURN 
1530 ! Build Array 3 Dimension
1540 BUILD_ARRAY_LIST_3_DEM:
1550 ARRAY_INFO1$=MID(COL'OCCURS$,1,(POS(","=COL'OCCURS$)-1))
1560 ARRAY_INFO2_TMP$=MID(COL'OCCURS$,POS(","=COL'OCCURS$)+1)
1561 ARRAY_INFO2$=MID(ARRAY_INFO2_TMP$,1,POS(","=ARRAY_INFO2_TMP$)-1)
1570 ARRAY_INFO3$=MID(ARRAY_INFO2_TMP$,POS(","=ARRAY_INFO2_TMP$)+1)
1580 ARRAY_POS1=POS(":"=ARRAY_INFO1$)
1590 ARRAY_POS2=POS(":"=ARRAY_INFO2$)
1600 ARRAY_POS3=POS(":"=ARRAY_INFO3$)
1610 ARRAY_PART1_START$=MID(ARRAY_INFO1$,1,ARRAY_POS1-1)
1620 ARRAY_PART1_END$=MID(ARRAY_INFO1$,ARRAY_POS1-LEN(ARRAY_INFO1$))
1630 MASK_PART1$=DIM(LEN(ARRAY_PART1_END$),"0")
1640 COUNT1=NUM(ARRAY_PART1_START$)
1650 COUNT2=NUM(ARRAY_PART1_END$)
1660 ARRAY_POS2=POS(":"=ARRAY_INFO2$,1,1)
1670 ARRAY_PART2_START$=MID(ARRAY_INFO2$,1,ARRAY_POS2-1)
1680 ARRAY_PART2_END$=MID(ARRAY_INFO2$,ARRAY_POS2-LEN(ARRAY_INFO2$))
1690 MASK_PART2$=DIM(LEN(ARRAY_PART2_END$),"0")
1700 COUNT3=NUM(ARRAY_PART2_START$)
1710 COUNT4=NUM(ARRAY_PART2_END$)
1720 ARRAY_POS3=POS(":"=ARRAY_INFO3$,1,1)
1730 ARRAY_PART3_START$=MID(ARRAY_INFO3$,1,ARRAY_POS3-1)
1740 ARRAY_PART3_END$=MID(ARRAY_INFO3$,ARRAY_POS3-LEN(ARRAY_INFO3$))
1750 MASK_PART3$=DIM(LEN(ARRAY_PART3_END$),"0")
1760 COUNT5=NUM(ARRAY_PART3_START$)
1770 COUNT6=NUM(ARRAY_PART3_END$)
1780 FOR I=COUNT1 TO COUNT2 STEP 1
1790 FOR T=COUNT3 TO COUNT4 STEP 1
1800 FOR Z=COUNT5 TO COUNT6 STEP 1
1805 DTCHK$=COL'CLASS$,COLUMN_TYPE$=STR_DATATYPE$; IF DTCHK$="DATE-KKMMDD" THEN COLUMN_TYPE$=DATE_DATATYPE$
1810 GOSUB CVT_COLUMN; DUP_CHECK$+=COLUMN_NAME$+"_"+STR(I:MASK_PART1$)+"_"+STR(T:MASK_PART2$)+"_"+STR(Z:MASK_PART3$)+SEP; CONTENTS$+=X$+QUO_CHAR$+COLUMN_NAME$+"_"+STR(I:MASK_PART1$)+"_"+STR(T:MASK_PART2$)+"_"+STR(Z:MASK_PART3$)+QUO_CHAR$+"     "+TBL(COL'TYPE$="S",TBL(COL'INTERNALFORMAT$<>"B",NUM_DATATYPE$+"("+STR(COL'LENGTH),NUM_DATATYPE$+"("+STR(COL'LENGTH)+TBL(COL'SCALE=0,","+STR(COL'SCALE),""))+")",TBL(POS("DATE"=COL'CLASS$)>0,COLUMN_TYPE$+"("+STR(COL'LENGTH)+")",COLUMN_TYPE$))+","+SEP+"   "
1820 X$=""
1830 NEXT Z
1840 NEXT T
1850 NEXT I
1860 RETURN 
9999 END 
10000 CVT_COLUMN:
10010 COLUMN_NAME$=COL'NAME$
10020 COLUMN_NAME$=STP(COLUMN_NAME$,2)
10490 RETURN 
10498 ! 
10500 CVT_IDX:
10510 IDX_NAME$=IDX'SEGMENT(S)'COLUMNNAME$
10520 IDX_NAME$=STP(IDX_NAME$,2)
10990 RETURN 
10999 ! 
11000 SETUP_DATATYPES:
11005 SWITCH DB_TYPE$
11020 CASE "M"
11025 STR_DATATYPE$="varchar",NUM_DATATYPE$="decimal",DATE_DATATYPE$="date"
11030 BREAK
11040 CASE "S"
11045 STR_DATATYPE$="varchar",NUM_DATATYPE$="decimal",DATE_DATATYPE$="datetime"
11050 BREAK
11060 CASE "O" ! Same as the DEFAULT
11070 ! 
11080 DEFAULT 
11090 STR_DATATYPE$="varchar2",NUM_DATATYPE$="number",DATE_DATATYPE$="date"
11095 END SWITCH 
11098 RETURN 
11099 ! 
56001 REM "257953-Report Suite Report to provide P & L that has columns for   
56002 REM "283979-Datareplication - Bulk load utility DR2EXP for MySQL data   
56003 REM "285801-Ability to control tablename case in CREATE statements   
56004 REM "296394-Needs help exporting single tables from DBD                 
